#!/usr/bin/env bash
# ralph - Multi-Agent Orchestrator CLI
# Version 2.20.0
# v2.20: Git worktree + PR workflow with multi-agent review
# v2.19: Security fixes (VULN-001, VULN-004, VULN-008), improved validation
set -euo pipefail

# SECURITY: Ensure all created files are user-only by default (VULN-008)
umask 077

VERSION="2.20.0"
RALPH_DIR="${HOME}/.ralph"

# SECURITY: Use mktemp for unpredictable temp directory
RALPH_TMPDIR=""
init_tmpdir() {
    if [ -z "$RALPH_TMPDIR" ]; then
        local SYSTEM_TMPDIR="${TMPDIR:-/tmp}"
        RALPH_TMPDIR=$(mktemp -d "${SYSTEM_TMPDIR}/ralph.XXXXXXXXXX")
        chmod 700 "$RALPH_TMPDIR"
    fi
}

# SECURITY: Validate file path input (prevent command injection)
# v2.19: VULN-004 FIX - Use realpath -e to resolve symlinks, improved validation
validate_path() {
    local path="$1"
    local check_exists="${2:-check}"

    # Block control characters (newlines, carriage returns, null bytes, etc.)
    if [[ "$path" =~ [[:cntrl:]] ]]; then
        log_error "Control characters not allowed in path"
        exit 1
    fi

    # Block shell metacharacters including glob patterns (*, ?, [])
    if [[ "$path" =~ [\;\|\&\$\`\(\)\{\}\<\>\*\?\[\]\!\~\#] ]]; then
        log_error "Invalid characters in path: $path"
        exit 1
    fi

    # Block path traversal attempts
    if [[ "$path" =~ \.\. ]]; then
        log_error "Path traversal not allowed: $path"
        exit 1
    fi

    # VULN-004 FIX: Use realpath -e to resolve symlinks and validate existence
    if [ "$check_exists" = "check" ]; then
        local canonical_path
        # -e flag: resolve all symlinks, path must exist
        canonical_path=$(realpath -e "$path" 2>/dev/null)

        if [ -z "$canonical_path" ]; then
            log_error "Path does not exist or contains invalid symlinks: $path"
            exit 1
        fi

        # Return the fully resolved canonical path
        printf '%s' "$canonical_path"
    else
        # For paths that don't need to exist yet, use -s (logical) but warn
        realpath -s "$path" 2>/dev/null || printf '%s' "$path"
    fi
}

# SECURITY: Validate text input (for non-path user inputs like TASK, QUERY)
# v2.17: NEW - Validates free-form text inputs
validate_text_input() {
    local input="$1"
    local max_len="${2:-10000}"

    # Block control characters except space/tab/newline
    if [[ "$input" =~ [[:cntrl:]] ]] && ! [[ "$input" =~ ^[[:print:][:space:]]*$ ]]; then
        log_error "Invalid control characters in input"
        exit 1
    fi

    # Check length limit
    if [ ${#input} -gt "$max_len" ]; then
        log_error "Input too long (max: $max_len characters)"
        exit 1
    fi

    printf '%s' "$input"
}

# SECURITY: Escape string for safe shell usage (VULN-001 FIX)
# v2.19: Use printf %q for proper escaping (prevents command substitution)
escape_for_shell() {
    # printf %q properly escapes all special characters including $() and ``
    printf '%q' "$1"
}
IMPROVEMENTS_DIR="${RALPH_DIR}/improvements"
CONFIG_DIR="${RALPH_DIR}/config"
HOOKS_DIR="${HOME}/.claude/hooks"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Iteration Limits
CLAUDE_MAX_ITER=15
MINIMAX_MAX_ITER=30
LIGHTNING_MAX_ITER=60

# Cleanup
cleanup() {
    [ -n "$RALPH_TMPDIR" ] && rm -rf "$RALPH_TMPDIR" 2>/dev/null || true
}
trap cleanup EXIT

ensure_tmp() {
    init_tmpdir
}
ensure_dirs() { mkdir -p "$IMPROVEMENTS_DIR/backups" "$CONFIG_DIR"; }

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# ===============================================================================
# HELP
# ===============================================================================
show_help() {
    cat << 'EOF'
ralph - Multi-Agent Orchestrator CLI v2.20.0

ORCHESTRATION:
  ralph orch "task"          Full orchestration (clarify->classify->execute->validate->retrospective)
  ralph loop "task"          Loop until VERIFIED_DONE (max 15 iter Claude, 30 MiniMax)
  ralph clarify "task"       Generate clarification questions

GIT WORKTREE + PR WORKFLOW (v2.20):
  ralph worktree "task"      Create isolated worktree for feature
  ralph worktree-pr          Create PR with Claude + Codex review
  ralph worktree-merge <pr>  Merge approved PR and cleanup
  ralph worktree-fix <pr>    Apply fixes from review comments
  ralph worktree-close <pr>  Close PR and cleanup without merge
  ralph worktree-status      Show all worktrees and PR status
  ralph worktree-cleanup     Clean up merged worktrees

REVIEW (6 SUBAGENTS):
  ralph review <path>        Multi-model review
  ralph parallel <path>      All 6 subagents in parallel
  ralph full-review <path>   Alias for parallel

SPECIALIZED:
  ralph security <path>      Security audit (Codex + MiniMax)
  ralph bugs <path>          Bug hunting (Codex)
  ralph unit-tests <path>    Unit tests (Codex, 90% coverage)
  ralph integration <path>   Integration tests (Gemini)
  ralph refactor <path>      Refactoring (Codex)
  ralph research "query"     Web research (Gemini)
  ralph minimax "query"      Second opinion (MiniMax ~8% cost)

VALIDATION:
  ralph gates                Quality gates (9 languages) - BLOCKING
  ralph gates --check        Quality gates (non-blocking check only)
  ralph adversarial <path>   2/3 consensus (Claude + Codex + Gemini)

SELF-IMPROVEMENT:
  ralph retrospective        Analyze last task, propose improvements
  ralph retro                Alias for retrospective
  ralph improvements         List pending improvements
  ralph improvements apply   Apply pending improvements
  ralph improvements reject  Reject improvements

UTILITY:
  ralph status               Show active processes
  ralph version              Show version
  ralph help                 Show this help
  ralph --uninstall          Uninstall ralph and all components

ITERATION LIMITS:
  Claude (Sonnet/Opus): 15 iterations
  MiniMax M2.1:         30 iterations (2x)
  MiniMax-lightning:    60 iterations (4x)

ALIASES (add to ~/.zshrc or ~/.bashrc):
  alias rh='ralph'
  alias rho='ralph orch'
  alias rhr='ralph review'
  alias rhp='ralph parallel'
  alias rhs='ralph security'
  alias rhb='ralph bugs'
  alias rhu='ralph unit-tests'
  alias rhf='ralph refactor'
  alias rhres='ralph research'
  alias rhm='ralph minimax'
  alias rhg='ralph gates'
  alias rha='ralph adversarial'
  alias rhl='ralph loop'
  alias rhc='ralph clarify'
  alias rhret='ralph retrospective'
  alias rhi='ralph improvements'
  alias rhw='ralph worktree'
  alias rhwp='ralph worktree-pr'
  alias rhws='ralph worktree-status'

EXAMPLES:
  ralph orch "Implement OAuth2 with Google"
  ralph security src/auth/
  ralph parallel src/ --async
  ralph adversarial src/payments/
  ralph loop "Fix all TypeScript errors"
  ralph retrospective

  # Worktree workflow (v2.20)
  ralph worktree "implement user authentication"
  cd .worktrees/ai-ralph-*/  # Work in isolated worktree
  ralph worktree-pr          # Create PR with multi-agent review
  ralph worktree-merge 123   # Merge approved PR
EOF
}

# ===============================================================================
# CODEX SUBAGENTS
# ===============================================================================
run_codex_security() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_security.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use security-review skill. Analyze for vulnerabilities in: ${SAFE_FILES}

         Output JSON: {vulnerabilities: [{severity, type, file, line, description, fix}], summary: {critical, high, medium, low, approved}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

run_codex_bugs() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_bugs.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use bug-hunter skill. Find bugs in: ${SAFE_FILES}

         Output JSON: {bugs: [{severity, type, file, line, description, fix}], summary: {total, high, medium, low, approved}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

run_codex_unit_tests() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_tests.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use test-generation skill. Generate unit tests for: ${SAFE_FILES}
         Target: 90% coverage. Include edge cases and error paths.

         Output JSON: {tests: [{file, content, coverage, type}], summary: {total_tests, estimated_coverage}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

# ===============================================================================
# GEMINI SUBAGENTS
# ===============================================================================
run_gemini_integration() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/gemini_integration.txt"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    gemini "Generate comprehensive integration tests for: ${SAFE_FILES}
            Include: API tests, database tests, external service mocks.
            Output ready-to-run test files." \
        --yolo -o text > "$OUTPUT" 2>&1 &
    echo $!
}

run_gemini_research() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local OUTPUT="$RALPH_TMPDIR/gemini_research.txt"
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")

    gemini "${SAFE_QUERY}" --yolo -o text > "$OUTPUT" 2>&1 &
    echo $!
}

# ===============================================================================
# MINIMAX SUBAGENTS
# ===============================================================================
run_minimax() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local OUTPUT="${2:-$RALPH_TMPDIR/minimax_result.json}"

    # Check for MiniMax config: primary path, then legacy fallback
    local MINIMAX_CONFIG=""
    if [ -f "${CONFIG_DIR}/minimax.json" ]; then
        MINIMAX_CONFIG="${CONFIG_DIR}/minimax.json"
    elif [ -f "${RALPH_DIR}/config/minimax.json" ]; then
        MINIMAX_CONFIG="${RALPH_DIR}/config/minimax.json"
    elif [ -f "${HOME}/.mmc.json" ]; then
        MINIMAX_CONFIG="${HOME}/.mmc.json"  # Legacy fallback
    fi

    if command -v mmc &> /dev/null && [ -n "$MINIMAX_CONFIG" ]; then
        local SAFE_QUERY
        SAFE_QUERY=$(escape_for_shell "$QUERY")
        mmc --query "${SAFE_QUERY}" > "$OUTPUT" 2>&1 &
        echo $!
    else
        echo "0"  # MiniMax not configured
    fi
}

# ===============================================================================
# ADVERSARIAL VALIDATION
# ===============================================================================
cmd_adversarial() {
    local TARGET
    TARGET=$(validate_path "$1")
    local CONSENSUS_REQUIRED=2
    local SAFE_TARGET
    SAFE_TARGET=$(escape_for_shell "$TARGET")

    ensure_tmp
    log_info "Starting adversarial validation for: $TARGET"
    log_info "   Consensus required: $CONSENSUS_REQUIRED/3"
    echo ""

    # 1. Claude Review
    log_info "  [1/3] Claude reviewing..."
    claude --print -p "Review this code for security and bugs: ${SAFE_TARGET}.
                       Output JSON: {approved: true|false, issues: [], severity: 'HIGH|MEDIUM|LOW'}" \
        > "$RALPH_TMPDIR/claude.json" 2>&1 &
    CLAUDE_PID=$!

    # 2. Codex Review (parallel)
    log_info "  [2/3] Codex reviewing..."
    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use security-review skill. Review: ${SAFE_TARGET}
         Output JSON: {approved: true|false, issues: [], severity}" \
        > "$RALPH_TMPDIR/codex.json" 2>&1 &
    CODEX_PID=$!

    # 3. Gemini Review (parallel)
    log_info "  [3/3] Gemini reviewing..."
    gemini "Security and code review for: ${SAFE_TARGET}
            Be critical. Output JSON: {approved: true|false, issues: []}" \
        --yolo -o json > "$RALPH_TMPDIR/gemini.json" 2>&1 &
    GEMINI_PID=$!

    echo ""
    log_info "Waiting for all 3 models..."
    wait $CLAUDE_PID $CODEX_PID $GEMINI_PID

    # Calculate consensus
    CLAUDE_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/claude.json" 2>/dev/null && echo "true" || echo "false")
    CODEX_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/codex.json" 2>/dev/null && echo "true" || echo "false")
    GEMINI_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/gemini.json" 2>/dev/null && echo "true" || echo "false")

    APPROVALS=0
    [[ "$CLAUDE_APPROVED" == "true" ]] && ((APPROVALS++)) || true
    [[ "$CODEX_APPROVED" == "true" ]] && ((APPROVALS++)) || true
    [[ "$GEMINI_APPROVED" == "true" ]] && ((APPROVALS++)) || true

    echo ""
    echo "==============================================================="
    echo "  ADVERSARIAL VALIDATION RESULTS"
    echo "==============================================================="
    echo ""
    echo "  Claude:  $([ "$CLAUDE_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo "  Codex:   $([ "$CODEX_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo "  Gemini:  $([ "$GEMINI_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo ""
    echo "  Consensus: $APPROVALS/3 (required: $CONSENSUS_REQUIRED)"
    echo ""

    if [[ $APPROVALS -ge $CONSENSUS_REQUIRED ]]; then
        log_success "ADVERSARIAL VALIDATION PASSED"
        echo "==============================================================="
        return 0
    else
        log_error "ADVERSARIAL VALIDATION FAILED"
        echo ""
        echo "  Issues found:"
        jq -s '.[].issues // [] | .[]' "$RALPH_TMPDIR"/*.json 2>/dev/null | head -20
        echo "==============================================================="
        return 2
    fi
}

# ===============================================================================
# PARALLEL REVIEW (6 SUBAGENTS)
# ===============================================================================
cmd_parallel() {
    local TARGET
    TARGET=$(validate_path "$1")
    local ASYNC="${2:-false}"

    ensure_tmp
    log_info "Launching 6 parallel subagents for: $TARGET"
    echo ""

    declare -a PIDS

    # 1. Codex Security
    PID=$(run_codex_security "$TARGET")
    PIDS+=("$PID")
    log_info "  [1/6] Codex Security: PID $PID"

    # 2. Codex Bugs
    PID=$(run_codex_bugs "$TARGET")
    PIDS+=("$PID")
    log_info "  [2/6] Codex Bugs: PID $PID"

    # 3. Codex Unit Tests
    PID=$(run_codex_unit_tests "$TARGET")
    PIDS+=("$PID")
    log_info "  [3/6] Codex Unit Tests: PID $PID"

    # 4. Gemini Integration
    PID=$(run_gemini_integration "$TARGET")
    PIDS+=("$PID")
    log_info "  [4/6] Gemini Integration: PID $PID"

    # 5. Gemini Research
    PID=$(run_gemini_research "code quality best practices for $TARGET")
    PIDS+=("$PID")
    log_info "  [5/6] Gemini Research: PID $PID"

    # 6. MiniMax Second Opinion
    PID=$(run_minimax "Provide critical code review for: $TARGET")
    if [ "$PID" != "0" ]; then
        PIDS+=("$PID")
        log_info "  [6/6] MiniMax Review: PID $PID"
    else
        log_warn "  [6/6] MiniMax: skipped (not configured)"
    fi

    echo ""

    if [ "$ASYNC" = "--async" ] || [ "$ASYNC" = "true" ]; then
        log_warn "Fire & forget mode. PIDs: ${PIDS[*]}"
        log_info "   Check results in: $RALPH_TMPDIR/"
        return 0
    fi

    log_info "Waiting for ${#PIDS[@]} subagents..."
    for pid in "${PIDS[@]}"; do
        wait "$pid" 2>/dev/null || true
    done

    log_success "All subagents completed"
    echo ""

    # Summary
    echo "==============================================================="
    echo "  PARALLEL REVIEW SUMMARY"
    echo "==============================================================="
    for f in "$RALPH_TMPDIR"/*; do
        if [ -f "$f" ]; then
            local name=$(basename "$f")
            local lines=$(wc -l < "$f" 2>/dev/null || echo 0)
            echo "  - $name: $lines lines"
        fi
    done
    echo "==============================================================="
}

# ===============================================================================
# QUALITY GATES (9 LANGUAGES)
# ===============================================================================
cmd_gates() {
    local CHECK_ONLY="${1:-}"
    local HOOK_SCRIPT="${HOOKS_DIR}/quality-gates.sh"

    # Check if hook exists
    if [ ! -f "$HOOK_SCRIPT" ]; then
        log_error "Quality gates hook not found at: $HOOK_SCRIPT"
        log_info "Run the installer to set up hooks: ./install.sh"
        return 1
    fi

    # Ensure executable
    if [ ! -x "$HOOK_SCRIPT" ]; then
        chmod +x "$HOOK_SCRIPT"
    fi

    # Run in blocking or check mode
    if [ "$CHECK_ONLY" = "--check" ]; then
        log_info "Running quality gates (non-blocking check)..."
        RALPH_GATES_BLOCKING=0 "$HOOK_SCRIPT"
    else
        log_info "Running quality gates (blocking mode)..."
        RALPH_GATES_BLOCKING=1 "$HOOK_SCRIPT"
    fi
}

# ===============================================================================
# SPECIALIZED COMMANDS
# ===============================================================================
cmd_security() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Running security audit on: $TARGET"

    # Codex (primary)
    log_info "  Starting Codex security audit..."
    PID1=$(run_codex_security "$TARGET")

    # MiniMax (second opinion)
    PID2=$(run_minimax "Security audit for: $TARGET. Check: injection, auth, secrets, crypto." "$RALPH_TMPDIR/minimax_security.json")

    if [ "$PID2" != "0" ]; then
        wait $PID1 $PID2
    else
        wait $PID1
    fi

    log_success "Security audit complete. Results in: $RALPH_TMPDIR/"
}

cmd_bugs() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Running bug hunting on: $TARGET"
    PID=$(run_codex_bugs "$TARGET")
    wait $PID
    log_success "Bug hunting complete."
    cat "$RALPH_TMPDIR/codex_bugs.json" 2>/dev/null | jq '.summary' || true
}

cmd_unit_tests() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Generating unit tests for: $TARGET"
    PID=$(run_codex_unit_tests "$TARGET")
    wait $PID
    log_success "Unit test generation complete."
}

cmd_integration() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Generating integration tests for: $TARGET"
    PID=$(run_gemini_integration "$TARGET")
    wait $PID
    log_success "Integration test generation complete."
}

cmd_refactor() {
    local TARGET
    TARGET=$(validate_path "$1")
    local SAFE_TARGET
    SAFE_TARGET=$(escape_for_shell "$TARGET")
    ensure_tmp

    log_info "Running refactoring analysis on: $TARGET"
    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Refactor: ${SAFE_TARGET}
         Focus on: DRY, SOLID, extract methods, simplify conditionals.
         Output: refactored code + explanation" \
        > "$RALPH_TMPDIR/codex_refactor.json" 2>&1
    log_success "Refactoring analysis complete."
}

cmd_research() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")
    ensure_tmp

    log_info "Researching: $QUERY"
    gemini "Research best practices and current solutions for: ${SAFE_QUERY}" \
        --yolo -o text > "$RALPH_TMPDIR/gemini_research.txt" 2>&1
    cat "$RALPH_TMPDIR/gemini_research.txt"
}

# ===============================================================================
# GIT WORKTREE + PR WORKFLOW (v2.20)
# ===============================================================================
WORKTREES_DIR=".worktrees"

# Verify WorkTrunk is installed
check_worktruck() {
    if ! command -v wt &> /dev/null; then
        log_error "WorkTrunk (wt) is required for git worktree workflow."
        log_info "Install with: brew install max-sixty/worktrunk/wt"
        log_info "Then run: wt config shell install && source ~/.zshrc"
        return 1
    fi
    return 0
}

# Create isolated worktree for a feature/task
cmd_worktree() {
    local TASK
    TASK=$(validate_text_input "${1:-}")

    if [ -z "$TASK" ]; then
        log_error "Usage: ralph worktree <task-description>"
        log_info "Example: ralph worktree 'implement oauth authentication'"
        return 1
    fi

    check_worktruck || return 1

    # Generate branch name from task
    local SANITIZED_TASK
    SANITIZED_TASK=$(echo "$TASK" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-40)
    local BRANCH_NAME="ai/ralph/$(date +%Y%m%d)-${SANITIZED_TASK}"

    log_info "Creating worktree for: $TASK"
    log_info "   Branch: $BRANCH_NAME"
    log_info "   Location: $WORKTREES_DIR/"

    # Ensure .worktrees directory exists
    mkdir -p "$WORKTREES_DIR"

    # Create worktree using WorkTrunk
    if ! wt switch -c "$BRANCH_NAME"; then
        log_error "Failed to create worktree"
        return 1
    fi

    # Get the worktree path
    local WT_PATH
    WT_PATH=$(git worktree list | grep "$BRANCH_NAME" | awk '{print $1}')

    if [ -z "$WT_PATH" ]; then
        log_error "Worktree created but path not found"
        return 1
    fi

    # Apply security hardening
    log_info "   Applying security hardening..."
    (
        cd "$WT_PATH" || exit 1
        git config --worktree core.hooksPath ".git-hooks-disabled" 2>/dev/null || true
        git config --worktree credential.helper "" 2>/dev/null || true
        git config --worktree push.default current 2>/dev/null || true
    )

    log_success "Worktree created: $WT_PATH"
    echo ""
    log_info "To launch Claude in this worktree:"
    echo "   cd $WT_PATH && claude"
    echo ""
    log_info "When done, create PR with:"
    echo "   ralph worktree-pr $BRANCH_NAME"
}

# Create PR with multi-agent review
cmd_worktree_pr() {
    local BRANCH="${1:-}"

    if [ -z "$BRANCH" ]; then
        # Try to get current branch
        BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        if [ -z "$BRANCH" ] || [[ ! "$BRANCH" =~ ^ai/ralph/ ]]; then
            log_error "Usage: ralph worktree-pr <branch>"
            log_info "Example: ralph worktree-pr ai/ralph/20260103-oauth-feature"
            log_info ""
            log_info "Available worktrees:"
            git worktree list 2>/dev/null | grep -v "bare" || echo "  None found"
            return 1
        fi
    fi

    check_worktruck || return 1

    # Verify gh is installed
    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required for PR workflow."
        log_info "Install with: brew install gh && gh auth login"
        return 1
    fi

    log_info "Creating PR for branch: $BRANCH"

    # Switch to branch
    log_info "   Switching to worktree..."
    wt switch "$BRANCH" 2>/dev/null || git checkout "$BRANCH"

    # Push to remote
    log_info "   Pushing to origin..."
    if ! git push -u origin "$BRANCH" 2>/dev/null; then
        log_warn "   Push failed (may already exist or no changes)"
    fi

    # Generate PR title from branch name
    local PR_TITLE
    PR_TITLE=$(echo "$BRANCH" | sed 's|ai/ralph/[0-9]*-||' | tr '-' ' ')

    # Create PR draft
    log_info "   Creating draft PR..."
    local PR_URL
    if PR_URL=$(gh pr create --draft \
        --title "feat: ${PR_TITLE}" \
        --body "## Summary

Auto-generated PR from worktree workflow.

## Branch
\`$BRANCH\`

## Review

Multi-agent review will be posted as comments.

---
ðŸ¤– Generated by ralph worktree-pr" 2>&1); then
        log_success "PR created: $PR_URL"
    else
        log_error "Failed to create PR: $PR_URL"
        return 1
    fi

    # Get PR number
    local PR_NUMBER
    PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

    if [ -z "$PR_NUMBER" ]; then
        log_warn "Could not extract PR number, skipping reviews"
        return 0
    fi

    # Multi-agent review
    log_info "   Starting multi-agent code review..."
    ensure_tmp

    # Get diff for review
    local DIFF_FILE="$RALPH_TMPDIR/pr_diff.txt"
    gh pr diff "$PR_NUMBER" > "$DIFF_FILE" 2>/dev/null || git diff main..."$BRANCH" > "$DIFF_FILE"

    # Claude Opus Review
    log_info "   [1/2] Claude Opus reviewing..."
    local CLAUDE_REVIEW
    CLAUDE_REVIEW=$(cat "$DIFF_FILE" | claude --print -m opus -p "Review this code diff for:
- Logic errors and edge cases
- Code quality and maintainability
- Potential bugs
- Best practices violations

Output format:
## Claude Opus Review

### Summary
[Brief summary]

### Issues Found
[List any BLOCKER, CRITICAL, HIGH, MEDIUM, LOW issues]

### Recommendations
[Suggestions for improvement]

If no major issues: 'APPROVED âœ…'
If blocking issues: 'BLOCKED âŒ - [reason]'" 2>&1 || echo "Claude review failed")

    # Post Claude review as comment
    if [ -n "$CLAUDE_REVIEW" ] && [ "$CLAUDE_REVIEW" != "Claude review failed" ]; then
        gh pr comment "$PR_NUMBER" --body "$CLAUDE_REVIEW" 2>/dev/null || log_warn "Failed to post Claude review"
        log_success "   Claude review posted"
    fi

    # Codex GPT-5 Review
    log_info "   [2/2] Codex GPT-5 reviewing..."
    local CODEX_REVIEW
    if command -v codex &> /dev/null; then
        CODEX_REVIEW=$(codex exec -m gpt-5 --reasoning high -C "$(pwd)" \
            "Review this code diff for security vulnerabilities, performance issues, and best practices.
             Diff file: $DIFF_FILE

             Output format:
             ## Codex GPT-5 Security Review

             ### Security Analysis
             [Security findings]

             ### Performance Analysis
             [Performance findings]

             ### Verdict
             'APPROVED âœ…' or 'BLOCKED âŒ - [reason]'" 2>&1 || echo "Codex review failed")

        if [ -n "$CODEX_REVIEW" ] && [ "$CODEX_REVIEW" != "Codex review failed" ]; then
            gh pr comment "$PR_NUMBER" --body "$CODEX_REVIEW" 2>/dev/null || log_warn "Failed to post Codex review"
            log_success "   Codex review posted"
        fi
    else
        log_warn "   Codex not available, skipping security review"
    fi

    # Analyze results
    echo ""
    echo "==============================================================="
    echo "  PR REVIEW SUMMARY"
    echo "==============================================================="
    echo ""
    echo "  PR: $PR_URL"
    echo "  Branch: $BRANCH"
    echo ""

    # Check for blockers
    local HAS_BLOCKER=false
    if echo "$CLAUDE_REVIEW" | grep -qiE "(BLOCKED|BLOCKER|CRITICAL)"; then
        HAS_BLOCKER=true
        log_warn "  Claude found blocking issues"
    else
        log_success "  Claude: APPROVED"
    fi

    if echo "$CODEX_REVIEW" | grep -qiE "(BLOCKED|BLOCKER|CRITICAL)"; then
        HAS_BLOCKER=true
        log_warn "  Codex found blocking issues"
    else
        log_success "  Codex: APPROVED"
    fi

    echo ""
    echo "  Next steps:"
    if [ "$HAS_BLOCKER" = true ]; then
        log_warn "  Reviews found issues. Options:"
        echo "    ralph worktree-fix $PR_NUMBER    # Apply fixes from review"
        echo "    ralph worktree-close $PR_NUMBER  # Close and abandon"
    else
        log_success "  All reviews passed! Options:"
        echo "    ralph worktree-merge $PR_NUMBER  # Merge PR"
        echo "    ralph worktree-fix $PR_NUMBER    # Make additional changes"
    fi
    echo "==============================================================="
}

# Merge approved PR and cleanup
cmd_worktree_merge() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-merge <pr-number>"
        log_info "Example: ralph worktree-merge 123"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_info "Merging PR #$PR_NUMBER..."

    # Mark PR ready for review
    log_info "   Marking PR as ready..."
    gh pr ready "$PR_NUMBER" 2>/dev/null || log_warn "PR may already be ready"

    # Wait for CI checks
    log_info "   Waiting for CI checks..."
    if ! gh pr checks "$PR_NUMBER" --watch 2>/dev/null; then
        log_warn "   CI checks may have issues, proceeding..."
    fi

    # Merge with squash
    log_info "   Merging with squash..."
    if gh pr merge "$PR_NUMBER" --squash --delete-branch; then
        log_success "PR #$PR_NUMBER merged!"

        # Cleanup worktree
        log_info "   Cleaning up worktree..."
        local BRANCH
        BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null || echo "")
        if [ -n "$BRANCH" ]; then
            wt remove "$BRANCH" 2>/dev/null || git worktree remove "$BRANCH" 2>/dev/null || true
            git branch -d "$BRANCH" 2>/dev/null || true
        fi
        git worktree prune 2>/dev/null || true

        log_success "Worktree cleanup complete"
    else
        log_error "Failed to merge PR #$PR_NUMBER"
        return 1
    fi
}

# Apply fixes based on review comments
cmd_worktree_fix() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-fix <pr-number>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_info "Fetching review comments for PR #$PR_NUMBER..."

    # Get PR branch
    local BRANCH
    BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null)

    if [ -z "$BRANCH" ]; then
        log_error "Could not find branch for PR #$PR_NUMBER"
        return 1
    fi

    # Switch to branch
    log_info "   Switching to: $BRANCH"
    wt switch "$BRANCH" 2>/dev/null || git checkout "$BRANCH"

    # Get comments
    local COMMENTS
    COMMENTS=$(gh pr view "$PR_NUMBER" --comments 2>/dev/null || echo "No comments found")

    echo ""
    echo "==============================================================="
    echo "  REVIEW COMMENTS FOR PR #$PR_NUMBER"
    echo "==============================================================="
    echo "$COMMENTS" | head -100
    echo "==============================================================="
    echo ""
    log_info "To apply fixes:"
    echo "   1. Review the comments above"
    echo "   2. Make necessary changes"
    echo "   3. Commit: git commit -am 'fix: address review comments'"
    echo "   4. Push: git push"
    echo "   5. Re-run review: ralph worktree-pr $BRANCH"
}

# Close PR and cleanup without merging
cmd_worktree_close() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-close <pr-number>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_warn "Closing PR #$PR_NUMBER without merging..."

    # Get branch before closing
    local BRANCH
    BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null || echo "")

    # Close PR
    gh pr close "$PR_NUMBER" --delete-branch 2>/dev/null || gh pr close "$PR_NUMBER"

    # Cleanup worktree
    if [ -n "$BRANCH" ]; then
        log_info "   Cleaning up worktree: $BRANCH"
        wt remove "$BRANCH" 2>/dev/null || git worktree remove "$BRANCH" 2>/dev/null || true
        git branch -D "$BRANCH" 2>/dev/null || true
    fi
    git worktree prune 2>/dev/null || true

    log_success "PR #$PR_NUMBER closed and cleaned up"
}

# Show status of all worktrees
cmd_worktree_status() {
    log_info "Git Worktree Status:"
    echo ""

    if command -v wt &> /dev/null; then
        wt list 2>/dev/null || git worktree list
    else
        git worktree list
    fi

    echo ""
    log_info "Active PRs from worktrees:"
    if command -v gh &> /dev/null; then
        gh pr list --author "@me" --json number,title,headRefName,state \
            --jq '.[] | select(.headRefName | startswith("ai/ralph")) | "  #\(.number) [\(.state)] \(.title)"' 2>/dev/null || echo "  None found"
    else
        echo "  (install gh for PR status)"
    fi
}

# Cleanup merged worktrees
cmd_worktree_cleanup() {
    log_info "Cleaning up merged worktrees..."

    # Find merged ai/ralph branches
    local MERGED_BRANCHES
    MERGED_BRANCHES=$(git branch --merged main 2>/dev/null | grep "ai/ralph" || echo "")

    if [ -z "$MERGED_BRANCHES" ]; then
        log_info "No merged ai/ralph branches found"
    else
        echo "$MERGED_BRANCHES" | while read -r branch; do
            branch=$(echo "$branch" | tr -d ' *')
            if [ -n "$branch" ]; then
                log_info "   Removing: $branch"
                wt remove "$branch" 2>/dev/null || git worktree remove "$branch" 2>/dev/null || true
                git branch -d "$branch" 2>/dev/null || true
            fi
        done
    fi

    # Prune worktree metadata
    git worktree prune 2>/dev/null || true

    # Clean .worktrees directory if empty
    if [ -d "$WORKTREES_DIR" ] && [ -z "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        rmdir "$WORKTREES_DIR" 2>/dev/null || true
    fi

    log_success "Cleanup complete"
    cmd_worktree_status
}

cmd_minimax() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")

    # Check for MiniMax config: primary path, then legacy fallback
    local MINIMAX_CONFIG=""
    if [ -f "${CONFIG_DIR}/minimax.json" ]; then
        MINIMAX_CONFIG="${CONFIG_DIR}/minimax.json"
    elif [ -f "${RALPH_DIR}/config/minimax.json" ]; then
        MINIMAX_CONFIG="${RALPH_DIR}/config/minimax.json"
    elif [ -f "${HOME}/.mmc.json" ]; then
        MINIMAX_CONFIG="${HOME}/.mmc.json"  # Legacy fallback
    fi

    if ! command -v mmc &> /dev/null || [ -z "$MINIMAX_CONFIG" ]; then
        log_error "MiniMax not configured."
        log_info "   Expected config at: ${CONFIG_DIR}/minimax.json"
        log_info "   Or legacy path: ~/.mmc.json"
        log_info "   Run: mmc --setup"
        return 1
    fi

    log_info "Querying MiniMax M2.1..."
    mmc --query "${SAFE_QUERY}"
}

cmd_clarify() {
    local TASK
    TASK=$(validate_text_input "$1")
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    log_info "Generating clarification questions for: $TASK"
    echo ""

    # Use Claude with the skill
    claude --print -p "Use the ask-questions-if-underspecified skill.

                       Task: ${SAFE_TASK}

                       Generate MUST_HAVE and NICE_TO_HAVE questions."
}

# ===============================================================================
# LOOP COMMAND
# ===============================================================================
cmd_loop() {
    local TASK
    TASK=$(validate_text_input "$1")
    local USE_MINIMAX="${2:-false}"
    local MAX_ITER=$CLAUDE_MAX_ITER
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    if [ "$USE_MINIMAX" = "--mmc" ] || [ "$USE_MINIMAX" = "--minimax" ]; then
        MAX_ITER=$MINIMAX_MAX_ITER
        log_info "Starting Ralph loop with MiniMax ($MAX_ITER iterations max)"
    elif [ "$USE_MINIMAX" = "--lightning" ]; then
        MAX_ITER=$LIGHTNING_MAX_ITER
        log_info "Starting Ralph loop with Lightning ($MAX_ITER iterations max)"
    else
        log_info "Starting Ralph loop with Claude ($MAX_ITER iterations max)"
    fi

    log_info "   Task: $TASK"
    echo ""

    local ITER=0
    while [ $ITER -lt $MAX_ITER ]; do
        ((ITER++))
        log_info "  Iteration $ITER/$MAX_ITER"

        # Execute task
        if [ "$USE_MINIMAX" = "--mmc" ] || [ "$USE_MINIMAX" = "--minimax" ]; then
            RESULT=$(mmc --query "${SAFE_TASK}. Check if complete, output VERIFIED_DONE if done." 2>&1)
        else
            RESULT=$(claude --print -p "${SAFE_TASK}. Check if complete, output VERIFIED_DONE if done." 2>&1)
        fi

        # Check for completion
        if echo "$RESULT" | grep -q "VERIFIED_DONE"; then
            log_success "Task completed at iteration $ITER"
            return 0
        fi
    done

    log_warn "Max iterations ($MAX_ITER) reached without VERIFIED_DONE"
    return 1
}

# ===============================================================================
# SELF-IMPROVEMENT COMMANDS
# ===============================================================================
cmd_retrospective() {
    ensure_dirs

    log_info "Running retrospective analysis..."
    echo ""

    # Detect if we're in the ralph-loop repo (for direct improvement commits)
    local REPO_DIR=""
    local OUTPUT_FILE=""

    if [ -f "./CLAUDE.md" ] && grep -q "Multi-Agent Ralph" "./CLAUDE.md" 2>/dev/null; then
        REPO_DIR="$(pwd)"
        OUTPUT_FILE="${REPO_DIR}/tests/RETROSPECTIVE.md"
        log_info "Detected ralph-loop repo: improvements will be saved to ${OUTPUT_FILE}"
    elif git remote -v 2>/dev/null | grep -q "multi-agent-ralph"; then
        REPO_DIR="$(git rev-parse --show-toplevel 2>/dev/null)"
        OUTPUT_FILE="${REPO_DIR}/tests/RETROSPECTIVE.md"
        log_info "Detected ralph-loop repo: improvements will be saved to ${OUTPUT_FILE}"
    fi

    local RETRO_OUTPUT
    RETRO_OUTPUT=$(claude --print -p "Use the retrospective skill.

                       Analyze the last task completed and propose improvements to the Ralph Wiggum system.

                       Categories to analyze:
                       1. Routing effectiveness (was complexity accurate?)
                       2. Clarification quality (right questions asked?)
                       3. Agent performance (which were useful?)
                       4. Quality gate effectiveness
                       5. Iteration efficiency

                       Output improvement proposals with:
                       - Type (routing_adjustment, clarification_enhancement, agent_behavior, new_command, delegation_update, quality_gate)
                       - File to modify (use paths relative to the repo root)
                       - Specific change
                       - Justification
                       - Risk level

                       IMPORTANT: Format output as a complete RETROSPECTIVE.md file with:
                       - Date header
                       - Task summary
                       - What went well
                       - Improvement opportunities
                       - Proposed changes in JSON format")

    echo "$RETRO_OUTPUT"

    # Save to repo if detected
    if [ -n "$OUTPUT_FILE" ]; then
        mkdir -p "$(dirname "$OUTPUT_FILE")"
        echo "$RETRO_OUTPUT" > "$OUTPUT_FILE"
        echo ""
        log_success "Retrospective saved to: $OUTPUT_FILE"
        echo ""
        log_info "To commit improvements:"
        echo "  git add tests/RETROSPECTIVE.md"
        echo "  git commit -m 'docs(retro): Add retrospective for [task description]'"
        echo "  git push origin main"
    else
        # Save to global improvements dir as fallback
        mkdir -p "$IMPROVEMENTS_DIR"
        echo "$RETRO_OUTPUT" > "$IMPROVEMENTS_DIR/pending.md"
        log_info "Saved to: $IMPROVEMENTS_DIR/pending.md"
        log_info "Use 'ralph improvements' to review"
    fi
}

cmd_improvements() {
    ensure_dirs
    local ACTION="${1:-list}"

    case "$ACTION" in
        list|"")
            log_info "Pending improvements:"
            if [ -f "$IMPROVEMENTS_DIR/pending.md" ] && [ -s "$IMPROVEMENTS_DIR/pending.md" ]; then
                cat "$IMPROVEMENTS_DIR/pending.md"
            else
                echo "  No pending improvements."
            fi
            ;;
        apply)
            shift
            local IDS="${1:-all}"
            log_info "Applying improvements: $IDS"
            # Create backup first
            cp -r "${HOME}/.claude" "$IMPROVEMENTS_DIR/backups/.claude-$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
            log_success "Backup created. Implement apply logic here."
            ;;
        reject)
            shift
            local IDS="${1:-all}"
            log_info "Rejecting improvements: $IDS"
            ;;
        *)
            log_error "Unknown action: $ACTION. Use: list, apply, reject"
            ;;
    esac
}

# ===============================================================================
# ORCHESTRATION
# ===============================================================================
cmd_orch() {
    local TASK
    TASK=$(validate_text_input "$1")
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    echo ""
    echo "==============================================================="
    echo "  RALPH WIGGUM v2.19 ORCHESTRATION"
    echo "==============================================================="
    echo ""
    echo "  NOTE: v2.19 includes security fixes and improved validation."
    echo "        Uses AskUserQuestion and EnterPlanMode."
    echo ""
    echo "  For best experience, use the Claude Code /orchestrator command"
    echo "  which provides native interactive questioning."
    echo ""
    echo "==============================================================="
    echo ""

    # Step 0: Auto-Plan Mode (inform user)
    log_info "[0/7] AUTO-PLAN MODE"
    log_info "   Non-trivial tasks automatically enter Plan Mode in Claude Code"
    echo ""

    # Step 1: Clarify (legacy CLI mode)
    log_info "[1/7] CLARIFY"
    log_info "   Generating clarification questions..."
    cmd_clarify "$TASK"
    echo ""
    log_warn "   For interactive questioning, use: claude then /orchestrator"
    read -p "Press Enter to continue after reviewing questions (or Ctrl+C to abort)..."

    # Step 2: Classify
    log_info "[2/7] CLASSIFY"
    claude --print -p "Use task-classifier skill. Classify complexity (1-10) for: ${SAFE_TASK}"
    echo ""

    # Step 3: Plan
    log_info "[3/7] PLAN"
    log_info "   In Claude Code, this step writes a detailed plan for approval"
    echo ""

    # Step 4: Delegate
    log_info "[4/7] DELEGATE"
    log_info "   Launching appropriate subagents..."

    # Step 5: Execute
    log_info "[5/7] EXECUTE"
    cmd_parallel . false

    # Step 6: Validate
    log_info "[6/7] VALIDATE"
    cmd_gates --check

    # Step 7: Retrospective
    log_info "[7/7] RETROSPECTIVE"
    cmd_retrospective

    echo ""
    echo "==============================================================="
    log_success "  ORCHESTRATION COMPLETE"
    echo "==============================================================="
}

# ===============================================================================
# UNINSTALL
# ===============================================================================
cmd_uninstall() {
    local UNINSTALL_SCRIPT="${RALPH_DIR}/../.local/share/ralph/uninstall.sh"

    # Try multiple locations
    if [ -f "./uninstall.sh" ]; then
        exec ./uninstall.sh "$@"
    elif [ -f "${HOME}/.ralph/uninstall.sh" ]; then
        exec "${HOME}/.ralph/uninstall.sh" "$@"
    else
        log_error "Uninstall script not found."
        log_info "Download from: https://github.com/yourrepo/multi-agent-ralph-loop"
        echo ""
        echo "Manual uninstall:"
        echo "  rm -f ~/.local/bin/ralph ~/.local/bin/mmc"
        echo "  rm -rf ~/.ralph"
        echo "  # Remove ralph sections from ~/.zshrc or ~/.bashrc"
        return 1
    fi
}

# ===============================================================================
# MAIN
# ===============================================================================
main() {
    local CMD="${1:-help}"
    shift || true

    case "$CMD" in
        # Orchestration
        orch|orchestrate)
            cmd_orch "$@"
            ;;
        loop)
            cmd_loop "$@"
            ;;
        clarify)
            cmd_clarify "$@"
            ;;

        # Review
        review|full-review)
            cmd_parallel "$@"
            ;;
        parallel)
            cmd_parallel "$@"
            ;;

        # Specialized
        security)
            cmd_security "$@"
            ;;
        bugs)
            cmd_bugs "$@"
            ;;
        unit-tests|tests)
            cmd_unit_tests "$@"
            ;;
        integration)
            cmd_integration "$@"
            ;;
        refactor)
            cmd_refactor "$@"
            ;;
        research)
            cmd_research "$@"
            ;;
        minimax|mm)
            cmd_minimax "$@"
            ;;

        # Validation
        gates)
            cmd_gates "$@"
            ;;
        adversarial|adv)
            cmd_adversarial "$@"
            ;;

        # Self-improvement
        retrospective|retro)
            cmd_retrospective
            ;;
        improvements|improve)
            cmd_improvements "$@"
            ;;

        # Git Worktree + PR Workflow (v2.20)
        worktree)
            cmd_worktree "$@"
            ;;
        worktree-pr)
            cmd_worktree_pr "$@"
            ;;
        worktree-merge)
            cmd_worktree_merge "$@"
            ;;
        worktree-fix)
            cmd_worktree_fix "$@"
            ;;
        worktree-close)
            cmd_worktree_close "$@"
            ;;
        worktree-status|wt-status)
            cmd_worktree_status
            ;;
        worktree-cleanup|wt-cleanup)
            cmd_worktree_cleanup
            ;;

        # Utility
        status)
            log_info "Active ralph processes:"
            ps aux | grep -E "(codex|gemini|mmc|ralph)" | grep -v grep || echo "  None"
            ;;
        version|-v|--version)
            echo "ralph v$VERSION"
            ;;
        help|-h|--help)
            show_help
            ;;
        --uninstall|uninstall)
            cmd_uninstall "$@"
            ;;
        *)
            log_error "Unknown command: $CMD"
            echo "Run 'ralph help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
